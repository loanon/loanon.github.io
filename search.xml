<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决plsql中文乱码问题]]></title>
    <url>%2F2018%2F11%2F26%2Fplsql-garble%2F</url>
    <content type="text"><![CDATA[步骤一：在plsql中执行 select userenv(‘language’) from dual; 语句来查看字符集。 步骤二：在环境变量中添加配置信息，名称为NLS_LANG，值为步骤一中的结果。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>PL SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring中类内部调用注解@Transaction方法事务失效问题]]></title>
    <url>%2F2018%2F06%2F26%2Fspring-aop-self-transaction%2F</url>
    <content type="text"><![CDATA[写在前面在最近的工作用dubbo修改发布restful协议的时候，遇到一个问题，dubbo内部写的是service，控制事务的时候，直接写了一个方法B，把A方法需要事务的内容放在里面。类似下面代码的方式进行调用，结果是事务无效。 12345678910111213141516171819202122@Service("testService")public TestServiceImpl implments TestService&#123; /** * 对外的接口方法 */ public String A()&#123; ... this.B(); ... &#125; @Transaction private String B()&#123; &#125;&#125; 原因查找一下资料和别人的经历，了解到，spring的aop事务是通过代理实现的，而上面的代码A方法中直接调用B方法是内部直接调用。不会触发spring的代理机制，而是直接调用。所以事务无效。 解决方法1.直接注入法想到既然直接调用没有效果，那么像注入Dao一样，将Service自己注入到自己里面，在通过引用进行调用不就好了。 示例代码如下。 12345678910111213141516171819202122232425@Service("testService")public TestServiceImpl implments TestService&#123; @Autowired private TestService testService; /** * 对外的接口方法 */ public String A()&#123; ... testService.B(); ... &#125; @Transaction private String B()&#123; &#125;&#125; 实测这样的方式，事务是有效的。但是也会引起其他的一些问题（目前我的项目里面没有出现，网上有相关的讨论）。问题就是，这样的代码会造成对象引用的无限递归。据说在springboot中会出问题。 2. 工具获取法还有就是使用SpringUtil等工具动态获取self对象后调用方法。 12345678910111213141516171819202122@Service("testService")public TestServiceImpl implments TestService&#123; /** * 对外的接口方法 */ public String A()&#123; ... TestService testService = SpringUtil.getBean("testService", TestService.class); testService.B(); ... &#125; @Transaction private String B()&#123; &#125;&#125; 最后其实应该尽量避免这种方式的事务模式。实在没办法，还是建议使用第二种方式处理。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 搭建WebService服务端]]></title>
    <url>%2F2018%2F06%2F14%2Fjava-webservice-server%2F</url>
    <content type="text"><![CDATA[写在前面之前在工作中遇到了和其他公司系统对接问题，对方提供的WebService接口，通过对接工作对WebService有了一定的了解。 现在公司也有微服务项目，主要使用的是dubbo，并定制化的加入了restful协议（详见当当网开源的dubbox）。WebService主要还是在一些老项目中使用，最近在进行一个老项目的重构改造工作，其中给其他项目提供的WebService接口要一并重写。要求呢，调用方直接修改接口地址即可。 Java 开发WebService服务端xfire查看项目老代码，老代码使用的是xfire搭建的WebService服务。基于要和原有服务保持一致的想法，准备使用xfire。 在项目中加入xfire依赖和相应配置，启动一直报错。百度发现，是因为xfire已经很久没更新，当时的spring 是2.x ，现在我们使用的spring是4.x。等于说这2个不兼容。遂决定放弃，另求他法。因此xfire方式就不细写了。有兴趣百度教程有很多。 cxfcxf 是Apache的项目，相比于xfire来说是一直在更新的，网上教程也很多。我主要借鉴的是https://blog.csdn.net/khsay/article/details/78054741。因为我是在原有项目中搭建的。文中只提取了WebService部分，可能会有错误。有问题可以与我讨论，或者查看我借鉴的这篇文章。 项目添加依赖我们项目用的是gradle作为构建工具 123compile group: 'org.apache.cxf', name: 'cxf-rt-frontend-jaxws', version: '3.2.4'compile group: 'org.apache.cxf', name: 'cxf-rt-transports-http', version: '3.2.4'compile group: 'org.apache.cxf', name: 'cxf-rt-ws-security', version: '3.2.4' 创建接口和实现类接口类 123456789101112package io.github.loanon.webservice.api;import javax.jws.WebMethod;import javax.jws.WebService;@WebServicepublic interface DemoService &#123; @WebMethod String callService(String xmlStr);&#125; 实现类 12345678910111213141516package io.github.loanon.webservice.api.impl;import javax.jws.WebService;import org.springframework.stereotype.Service;import io.github.loanon.webservice.api.DemoService@Service("demoService")@WebService(targetNamespace = "https://services.webServices.loanon.github.io", serviceName = "demoService")public class DemoServiceImpl implements DemoService &#123; @Override public String callService(String xmlStr) &#123; //TODO your code return ""; &#125;&#125; XML配置添加spring-cxf.xml并在spring的applicationContext.xml中引入 applicationContext.xml 12&lt;!-- webService --&gt;&lt;import resource="classpath:spring-config/spring.cxf.xml"/&gt; spring-cxf.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cxf="http://cxf.apache.org/core" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd"&gt; &lt;!--发布服务--&gt; &lt;jaxws:endpoint id="DemoService" implementor="io.github.loanon.webservice.api.impl.DemoServiceImpl" address="/demoService"&gt; &lt;/jaxws:endpoint&gt; &lt;cxf:bus&gt; &lt;cxf:features&gt; &lt;cxf:logging/&gt; &lt;/cxf:features&gt; &lt;/cxf:bus&gt;&lt;/beans&gt; 在web.xml中加入cxf的Servlet。 123456789&lt;!--cxf --&gt;&lt;servlet&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 验证浏览器访问123456789101112131415161718# 写在最后前面说到要保持和原有项目平滑过渡。就是说对于调用方只需要改一下地址，不用改代码就可以直接调用新服务。所以尽量和原有服务在协议上保持一致，目前看到的时候请求报文中会有方法名，所以只将方法名保持一致。当然这个有待测试。只有等联调结果，才能确定。soapUI 中WebService的请求报文。```xml&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:api=&quot;http://api.webservice.loanon.github.io/&quot;&gt; &lt;soapenv:Header/&gt; &lt;soapenv:Body&gt; &lt;!-- 这个节点有方法名信息 --&gt; &lt;api:callService&gt; &lt;!--Optional:--&gt; &lt;arg0&gt;?&lt;/arg0&gt; &lt;/api:callService&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信、支付宝付款码二合一(二)]]></title>
    <url>%2F2018%2F06%2F12%2Falipay-and-wechatpay-2%2F</url>
    <content type="text"><![CDATA[写在前面接前面一篇，上篇最后说到的微信不能识别是因为没有域名，其实是不对的。其实是因为微信扫码支付和支付宝扫码支付不一样，不是一个http请求。是“wxp”开头的。 为此特意找到之前看到的那篇文章（已经找不到链接了，好像是少数派上面的，有兴趣可以找找看，搜关键字二维码）。 我的方案通过分别用微信和支付宝扫文章中合成之后的付款码发现，他们的二维码在微信中就不是直接打开支付界面，而是打开带有微信付款码的页面，通过长按识别二维码进行付款。 所以对上篇中html进行改造，并将页面和二维码图片放到本博客的GitHub仓库下，通过GitHub的页面进行访问，这样微信也是可以打开的。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;支付宝-微信扫码支付&lt;/title&gt; &lt;meta charset="UTF-8"/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id="message"&gt;&lt;/h1&gt;&lt;div id="wechatPay" style="text-align: center; padding-top: 50px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;function isAlipayOrWechat() &#123; var userAgent = navigator.userAgent.toLowerCase(); if(userAgent.indexOf("alipay") != -1) &#123; window.location.href="HTTPS://QR.ALIPAY.COM/FKX00483JOOAAMITN2W2C1"; &#125; else if(userAgent.indexOf("micromessenger") != -1) &#123; document.getElementById('wechatPay').innerHTML='&lt;img style="width:80%;" src="./wechatPay.svg"&gt;&lt;h1 id="message"&gt;长按识别二维码向我付款&lt;/h1&gt;'; &#125;else&#123; document.getElementById('message').innerHTML="请使用支付宝或者微信扫码"; &#125;&#125;isAlipayOrWechat();&lt;/script&gt;&lt;/html&gt; 看看效果吧！ 写在最后而且我参考的那篇文章中，也有很多人提到，通过第三方平台进行这样的合成存在安全问题。如果自己写的并放在自己的GitHub仓库中，至少不会被别人偷偷修改掉链接地址。 当然，也许是我考虑的不周全，有建议也希望能向我提出来。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
        <tag>微信</tag>
        <tag>扫码支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信、支付宝付款码二合一]]></title>
    <url>%2F2018%2F05%2F14%2Falipay-and-wechatpay%2F</url>
    <content type="text"><![CDATA[写在前面前段时间，看到有网站可以将微信和支付宝的付款码合并成一个，觉得很有意思，但是在我准备尝试的时候发现是收费的。 作为一个天天付钱不收钱的，这就没有必要了。其实之前在店里面扫码付钱的时候好像就见过这样的付款码。 今天突发奇想，作为一个码农，自己就可以写一个呀。 思路二合一无非就是微信或者支付宝扫码打开的都是同一个服务请求。服务器接收到请求的时候根据如request中的useragent进行判断。根据判断结果将请求重定向到对应app的地址。 过程这样分析之后我们就需要知道支付宝和微信的useragent都是什么。通过网上查询知道支付宝的useragent中有Alipay，微信的useragent中有micromessenger。 然后就自己动手，在之前搭建的一个web项目中新增加一个方法。 代码完成之后在浏览器访问发现没有反应。将请求地址（局域网地址）生成为二维码。使用手机（与电脑在同一局域网）支付宝扫码测试发现可以打开，微信扫码会提示不是域名访问。处于安全考虑不允许打开。 这么看方法应该是对的，可惜没有买域名和vps，这个也是能自己这么玩玩了。 之后因为微信要是进行服务端重定向需要域名才行，只能到此为止了。 之后突然想到，也可以通过js进行前端的判断，之后通过window.location.href进行“重定向”。 123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id="message"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;script&gt;function isAlipayOrWechat() &#123; var userAgent = navigator.userAgent.toLowerCase(); if(userAgent.indexOf("alipay") != -1) &#123; window.location.href="HTTPS://QR.ALIPAY.COM/FKX00483JOOAAMITN2W2C1"; &#125; else if(userAgent.indexOf("micromessenger") != -1) &#123; window.location.href="wxp://f2f0fHq8R3hDDhWV4a6sKZrb5_EF0CGMljOP"; &#125;else&#123; document.getElementById('message').innerHTML="请使用支付宝或者微信扫码"; &#125;&#125;isAlipayOrWechat();&lt;/script&gt;&lt;/html&gt; 用nginx在局域网测试发现支付宝是可以成功的。微信前面说了有限制，也就没有尝试了 这样只要一个html就可以，比如可以把这个html放到这个博客里面，这样不就不需要买域名和vps了。 可是当我把文件放到博客之后，还是支付宝可以成功。微信扫码打开就只是一个空白页。看来微信做了限制，不允许通过window.location.href来指定页面请求。 最后目前这个功能也就这样了，后面有机会买了vps和域名，再试试吧，先记一下。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
        <tag>微信</tag>
        <tag>扫码支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner笔记]]></title>
    <url>%2F2018%2F05%2F14%2Fpowerdesigner-note%2F</url>
    <content type="text"><![CDATA[使用PowerDesigner逆向工程今天准备把之前做的一个小项目的数据模型整理一下，就想到了用PowerDesigner。安装完成之后，连接数据库，测试连接,提示报错。主要遇到2个错误，记一下解决方法。 1. Could not Initialize JavaVM!百度看到有人说是用了64位的jdk，才想到安装的PowerDesigner 16.5是32位的。查看解决办法就是使用32位的jdk。我猜想如果PowerDesigner是64位的话，使用64位jdk也应该没问题，下次有机会试一下。 2. Non SQL Error : Could not load class com.mysql.jdbc.Driver这个问题，以前第一次使用这个功能就遇到过，是找不到MySQL的jdbc驱动，只要将驱动jar的路径加入到系统的环境变量classpath就好了。 总结因为已经安装jdk，再次安装新的jdk会让系统的配置比较乱，特别是环境变量已经配置好的情况下，为了使用PowerDesigner修改环境变量总是觉得不太好。在网上找到个人比较喜欢的方法。 在PowerDesigner的安装目录中新建一个bat文件，写入如下脚本，具体路径根据个人电脑配置决定。 123Set JAVA_HOME=D:\Software\Java_x86\jdk1.8.0_144Set CLASSPATH=C:\Users\DinGZG\.m2\repository\mysql\mysql-connector-java\5.1.40\mysql-connector-java-5.1.40.jarpdshell16.exe 需要使用连接数据库的时候就通过脚本启动软件即可。]]></content>
      <tags>
        <tag>PowerDesigner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java强转null问题]]></title>
    <url>%2F2018%2F04%2F09%2Fjava-null-convert%2F</url>
    <content type="text"><![CDATA[可以强转为引用类型 不能强转成基本类型 因为转成基本类型会调用引用类型自动拆箱的方法，会引起空指针异常（NullPointException）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>null</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 使用技巧]]></title>
    <url>%2F2017%2F11%2F26%2Fhexo-skill%2F</url>
    <content type="text"><![CDATA[本博客是用hexo搭建在GitHub上的，写这篇文章只是为了记录一下hexo使用的一些命令和技巧，因为不是天天写博客（实在没那么高产），一段时间hexo命令就有些不记得了，记录一下备用。 1.新建博文 1hexo new 2.清除缓存 1hexo clean 3.生成文档 1hexo g //hexo generate 4.本地起服务预览 1hexo s //hexo server 5.发布到GitHub 1hexo d //hexo deploy 其他命令： hexo new page”pageName” #新建页面 hexo help # 查看帮助 hexo version #查看Hexo的版本 技巧： 1.部署时保证README.md文件不被渲染 _config.yml中配置一下”skip_render”选项 1skip_render: README.md]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gradle给旧项目打包]]></title>
    <url>%2F2017%2F11%2F26%2Fgradle-build-old-project%2F</url>
    <content type="text"><![CDATA[下载gradle并配置环境变量完成后在命令行输入gradle -v，查看是否配置正确。 建立配置文件在项目根目录新建名为build.gradle的配置文件。 文件中写入如下配置： 123456789101112131415161718192021222324252627282930313233343536apply plugin: 'war'// 设置 JDK 版本sourceCompatibility = 1.6// 设置 WebApp 根目录webAppDirName = 'WebRoot'// 设置 Java 源码所在目录sourceSets &#123; main &#123; java&#123; // 多个目录 srcDirs 单个用 srcDir '' srcDirs = ['soo','src/main/java','coresrc/main/java'] &#125; resources&#123; // 多个目录 srcDirs 单个用 srcDir '' srcDirs = ['src/main/resources','coresrc/main/resources'] &#125; &#125;&#125;// 设置 maven 库地址repositories &#123; maven &#123;url "http://maven.aliyun.com/nexus/content/groups/public/"&#125; mavenLocal()&#125;dependencies &#123; tasks.withType(JavaCompile) &#123; options.encoding = "GBK" &#125; // 本地依赖 compileOnly files('F:/lib/weblogic.jar','F:/lib/ojdbc14.jar') // 有网络是用maven // providedCompile 'javax.servlet:servlet-api:2.5' // 编译期 compile fileTree(dir: 'WebRoot/WEB-INF/lib', include: ['*.jar'])&#125; 因为我的项目有多个java源文件目录和资源目录所以配置的是srcDirs。如果只有一个目录，配置srcDir即可。至于每个配置项什么含义就需要自己找资料了，基本实现打包功能不需要很多的配置，像srcDir就是配置一下java源代码位置就好了。 编译打包在项目根目录打开命令行窗口，输入指令gradle clean build。如果成功会在结束时出现BUILD SUCCESSFUL。如果没有请查看报错信息，针对性的修改build.gradle里面的配置。 打包完成的war包就在 ./build/libs/目录下。 扩展上面说的都是自己用的，那么要是团队都来使用gradle，该如何统一。 假如现在项目组的同事也想和我一样使用gradle打包，直接的做法就是我将build.gradle提交svn，大家更新下来，安装gradle后，更改自己的本地依赖位置（其实既然使用了gradle，依赖可以都放到maven私有仓库，这样大家可以共用一套配置）。运行gradle clean build即可打包。 按照上面的做法，其实gradle和maven除了配置文件不同，基本没啥区别了。其实gradle提供了另一套便于统一协作的机制-gradlew。使用gradlew需要在项目根目录执行gradle init命令。会生成wapper的配置文件。可以将这些文件一同提交svn，其他同事更新后无需安装gradle，直接执行gradlew clean build。gradle会查找本地的gradle环境，没有的话会根据wapper配置去互联网下载对应版本的gradle进行编译打包。省去自行下载配置环境，还可以保持大家gradle版本的统一。 当然了，国内特殊原因，以及每个开发者所处的网络环境不同，下载速度也会受影响。上面的做法不一定能行的通，如果条件不允许，还是自己手动下载gradle并进行配置。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记PLSQL Developer设置oralce instantclient 进行远程连接经历]]></title>
    <url>%2F2017%2F11%2F10%2Fplsql-oracle%2F</url>
    <content type="text"><![CDATA[相关软件： PLSQL Developer 12(64bit) oracle instantclient-basic-windows.x64-12.2.0.1.0 都可以去对应的官网上下载。 按照网络上博客的教程解压 instantclient-basic-windows.x64-12.2.0.1.0.zip 并配置相应的环境变量以及PLSQL设置，发现 PLSQL Developer 没有远程数据库的配置。并且直接点击连接会提示没有正确安装 oracle 客户端。 搜索类似问题，有博客提到 instantclient12_2 需要 vs2013 运行库支持，让我想起来oracle的下载页面确实有相关提示。下载运行库进行安装，还是没有远程数据库的配置，但是直接点击连接会报oracle的连接错误。这说明现在客户端已经安装正确。应该是相关配置有问题。 重新检查环境变量配置，发现TNS_ADMIN配置错了，重新配置，指定到tnsnames.ora所在目录。测试发现只要该目录下有tnsnames.ora文件即可，不一定非要network/admin目录。但是保险起见，还是设置成network/admin目录。并在该目录下放置tnsnames.ora文件，文件中配置自己的数据库地址信息。 重新打开PLSQL，可以正常连接oracle数据库了。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>PL SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米6手机升级 MIUI9 小记]]></title>
    <url>%2F2017%2F08%2F21%2Fxiaomi6-miui9%2F</url>
    <content type="text"><![CDATA[同事买了小米6，最近小米也一直在宣传新系统 MIUI9 ，刚好看到可以下载就下载来刷机了。 刷机前还特意备份了一下数据，之前我也用过小米，刷机也一直都是这样备份系统，刷好了再恢复回来。 不过今天出问题了，同事刷完机，开机准备恢复数据，发现备份没有了，找遍了文件管理，发现所有的文件都没有了。看来是被格式化了。 上网查了一下，还真的是格式化了。原来是 跨版本刷机属于降级操作会自动清空手机里所有数据 。所有的地方都是提示要备份，但是就是没有提示要备份到手机之外，这个有点坑爹啊。 看来下次有什么刷机，重装啥的，还是要用电脑进行备份。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>MI6</tag>
        <tag>MIUI9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 调用第三方 webservice 服务]]></title>
    <url>%2F2017%2F08%2F18%2Fjava-webservice%2F</url>
    <content type="text"><![CDATA[原由公司要求我们的系统要和第三方系统同步数据。跟第三方沟通之后发现对方提供的是 webservice 接口，作为没有接触过 webservice 的小白，表示有点慌。 下面是请求接口 “http://www.xxxx.com/webservice/service/baseInfo?wsdl&quot; 的 XML 结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:tns="http://webservice.baseInfo.webservice.xxxx.com/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:ns1="http://schemas.xmlsoap.org/soap/http" name="BaseInfoWebServiceImplService" targetNamespace="http://webservice.baseInfo.webservice.xxxx.com/"&gt; &lt;wsdl:types&gt; &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://webservice.baseInfo.webservice.xxxx.com/" elementFormDefault="unqualified" targetNamespace="http://webservice.baseInfo.webservice.xxxx.com/" version="1.0"&gt; &lt;xs:element name="getOrgListByCode" type="tns:getOrgListByCode"/&gt; &lt;xs:element name="getOrgListByCodeResponse" type="tns:getOrgListByCodeResponse"/&gt; &lt;xs:element name="getOrgListByTime" type="tns:getOrgListByTime"/&gt; &lt;xs:element name="getOrgListByTimeResponse" type="tns:getOrgListByTimeResponse"/&gt; &lt;xs:element name="getUserListByTime" type="tns:getUserListByTime"/&gt; &lt;xs:element name="getUserListByTimeResponse" type="tns:getUserListByTimeResponse"/&gt; &lt;xs:complexType name="getOrgListByCode"&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg1" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg2" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg3" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg4" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg5" type="xs:string"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="getOrgListByCodeResponse"&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="getUserListByTime"&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg1" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg2" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg3" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg4" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg5" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg6" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg7" type="xs:string"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="getUserListByTimeResponse"&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="getOrgListByTime"&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs="0" name="arg0" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg1" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg2" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg3" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg4" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg5" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg6" type="xs:string"/&gt; &lt;xs:element minOccurs="0" name="arg7" type="xs:string"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="getOrgListByTimeResponse"&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs="0" name="return" type="xs:string"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;/xs:schema&gt; &lt;/wsdl:types&gt; &lt;wsdl:message name="getOrgListByTime"&gt; &lt;wsdl:part element="tns:getOrgListByTime" name="parameters"/&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="getOrgListByCodeResponse"&gt; &lt;wsdl:part element="tns:getOrgListByCodeResponse" name="parameters"/&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="getOrgListByCode"&gt; &lt;wsdl:part element="tns:getOrgListByCode" name="parameters"/&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="getUserListByTimeResponse"&gt; &lt;wsdl:part element="tns:getUserListByTimeResponse" name="parameters"/&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="getUserListByTime"&gt; &lt;wsdl:part element="tns:getUserListByTime" name="parameters"/&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="getOrgListByTimeResponse"&gt; &lt;wsdl:part element="tns:getOrgListByTimeResponse" name="parameters"/&gt; &lt;/wsdl:message&gt; &lt;wsdl:portType name="BaseInfoWebService"&gt; &lt;wsdl:operation name="getOrgListByCode"&gt; &lt;wsdl:input message="tns:getOrgListByCode" name="getOrgListByCode"/&gt; &lt;wsdl:output message="tns:getOrgListByCodeResponse" name="getOrgListByCodeResponse"/&gt; &lt;/wsdl:operation&gt; &lt;wsdl:operation name="getUserListByTime"&gt; &lt;wsdl:input message="tns:getUserListByTime" name="getUserListByTime"/&gt; &lt;wsdl:output message="tns:getUserListByTimeResponse" name="getUserListByTimeResponse"/&gt; &lt;/wsdl:operation&gt; &lt;wsdl:operation name="getOrgListByTime"&gt; &lt;wsdl:input message="tns:getOrgListByTime" name="getOrgListByTime"/&gt; &lt;wsdl:output message="tns:getOrgListByTimeResponse" name="getOrgListByTimeResponse"/&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:binding name="BaseInfoWebServiceImplServiceSoapBinding" type="tns:BaseInfoWebService"&gt; &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt; &lt;wsdl:operation name="getOrgListByCode"&gt; &lt;soap:operation soapAction="" style="document"/&gt; &lt;wsdl:input name="getOrgListByCode"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name="getOrgListByCodeResponse"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;wsdl:operation name="getUserListByTime"&gt; &lt;soap:operation soapAction="" style="document"/&gt; &lt;wsdl:input name="getUserListByTime"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name="getUserListByTimeResponse"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;wsdl:operation name="getOrgListByTime"&gt; &lt;soap:operation soapAction="" style="document"/&gt; &lt;wsdl:input name="getOrgListByTime"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name="getOrgListByTimeResponse"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name="BaseInfoWebServiceImplService"&gt; &lt;wsdl:port binding="tns:BaseInfoWebServiceImplServiceSoapBinding" name="BaseInfoWebServiceImplPort"&gt; &lt;soap:address location="http://www.xxxx.com/webservice/services/baseInfo"/&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt;&lt;/wsdl:definitions&gt; 注：因为涉及客户的具体信息，接口以及 XML 中 location、schema 等地址是假的。 过程axis2遇到不会的东西当然是上网搜索找资料了，找了一个博客看了一下，使用 axis2 开发 webservice 客户端代码，但是当我按照博客的教程引入了依赖写好 demo 代码测试，一直报错。这个方法没成功，也没详细了解，就不赘述了。因为搜索的时候看到还有别的方式，所以还是继续找资料。 wsimport这次是用 Java 自带的 wsimport 工具分析 webservice 来生成代码，将 webservice 转化成 Java 服务来直接调用。 wsimport.exe 文件在 JDK 的 bin 目录下，可以在这个目录下直接启动命令行，输入命令 1wsimport -keep -p com.loanon.client.wsimport http://www.xxxx.com/webservice/service/baseInfo?wsdl 就会在 bin 目录下按照包名路径生成代码。 这里简单说一下 wsimport 的参数 12-keep //在生成class文件，或者jar包时，同时保留java源文件-p &lt;pkg&gt; //指定生成文件的包结构 所以上面的文件夹里面会有 .java 和 .class 两种文件。有了这些文件可以直接将 class 文件打成 jar 包作为依赖引入到项目中。也可以把 .java 源码放到项目中。我选择的是第二种。 我先写了一个单机的 demo 进行测试。其实第一次看到这些生成的代码是不知所措的，网上找到了的博客中，别人的描述和我生成的代码根本不一样，可以说没有联系。也许是 Java 版本的原因，也许是 webservice 接口差异的原因。看别人写的 main 方法中调用代码的方式在我的代码中没有办法做到。于是就点开源码挨个查看。终于有点头绪。 HttpConnection实在没办法了。按道理来说使用wsimport工具已经是最简单的方法了，而且写的demo可以运行，但是放到公司项目中就报错（Expection 报的是 XML Namespace 之类的，具体原因我没有去找，要是有类似问题知道原因 可以告知讨论一下）。 不过现在我已经对webservice有了一些了解。知道它就是一个http请求。只是需要按照指定的格式来传递数据（XML 报文）。通过webservice工具和Fiddler已经抓取了这个请求的报文，是一个xml。所以我决定自己直接通过Java的http请求发送报文来请求对于数据。这次可以成功返回数据，只是返回的数据还是xml，需要自己解析。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>webservice</tag>
      </tags>
  </entry>
</search>
